[task-asynchronous-programming-model](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model)
 
 [Thread چیست؟](https://blog.faradars.org/thread-%DA%86%DB%8C%D8%B3%D8%AA/)
 [ProcessThreadsView](https://www.nirsoft.net/utils/process_threads_view.html)

[C# Advanced - Multi-Threading](https://www.youtube.com/watch?v=nBMgY_CoLwM)
>main thread = control thread 

[multithreading-in-csharp](https://dotnettutorials.net/lesson/multithreading-in-csharp/)

[Task And Thread In C#](https://www.c-sharpcorner.com/article/task-and-thread-in-c-sharp/#:~:text=Here%20are%20some%20differences%20between,task%20can%20return%20a%20result.)

[C# Error and Performance Monitoring](https://sentry.io/for/csharp/?utm_source=google&utm_medium=cpc&utm_id=%7B19666612445%7D&utm_campaign=Google_Search_NB_LanguageSpecific_Performance_EMEA_Beta&utm_content=g&utm_term=c%23%20performance%20monitoring&gad=1&gclid=Cj0KCQjwusunBhCYARIsAFBsUP_cMc6_UnQ_KcHDjBu1hTimjQSteq5GGEfaDwhmA34SWXpcOLm1rDYaAukMEALw_wcB)

[Event Tracing for Windows (ETW)](https://learn.microsoft.com/en-us/windows/win32/etw/event-tracing-portal?redirectedfrom=MSDN)

[OpenTelemetry with Auto-instrumentation](https://medium.com/@bijit211987/opentelemetry-with-auto-instrumentation-18f7688f0209#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjgzOGMwNmM2MjA0NmMyZDk0OGFmZmUxMzdkZDUzMTAxMjlmNGQ1ZDEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDk5ODUwOTEyNDM5MTIyMjk2NTkiLCJlbWFpbCI6InBhbGFuZ2kxMjJAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm5iZiI6MTY5MzgxMzQ2MCwibmFtZSI6Ik1haG1vb2QgUGFsYW5naSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BQWNIVHRldUFSV2tmT25iQzQyTlVfcEswV3ZfREVrYjlYaWxWa2RJZDlkaHNYN3JLTWM9czk2LWMiLCJnaXZlbl9uYW1lIjoiTWFobW9vZCIsImZhbWlseV9uYW1lIjoiUGFsYW5naSIsImxvY2FsZSI6ImVuIiwiaWF0IjoxNjkzODEzNzYwLCJleHAiOjE2OTM4MTczNjAsImp0aSI6IjVjYjE0ODVkYzhhZjk3ZDkzMmUzYWQ1MmU2MDRkMjJlMzIyYTE5OTkifQ.XWXpEsHdzdsbFkZSBWzDW5dTpCYoI9gtDrv1Sd9LBIc3hMqaQxb8XOeIOVbZZDSA0zHGjkgwu0sAHMgBx4Y_5jypkPrblKo98JCRFod2Fi5uRzrdUR2p17tEeh0eLXb7vZ1s-OblEmPQ2hnqjqIdmoIKGdGoA5WEQ9MppZpDl6TbrCXuB5lPaXZHYxLhJ-mas9NoBy9cyuYNiW6ajakodSey7q7JwS0Mf0_r32mBf4sOQFZVrNaSOXniktfWyqk4jOuRFlRJuEaif_sjx9Cab19ycLy63VMaM8XwCvXl5zshqgFtJi3OnfuMEnlohU4lwpYm7SxxUgvaZeSzQNCYEQ)

[python-opentelemetry-auto-instrumentation](https://logz.io/blog/python-opentelemetry-auto-instrumentation/#collect)

[dotnet/core/diagnostics/metrics-instrumentation](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/metrics-instrumentation)

[diagnostics/metrics-collection](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/metrics-collection)

[instrumentation](https://prometheus.io/docs/practices/instrumentation/)

[opentelemetry-dotnet](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/metrics/customizing-the-sdk/README.md)

[getting-started-with-opentelemetry-metrics-and-dotnet](https://www.mytechramblings.com/posts/getting-started-with-opentelemetry-metrics-and-dotnet-part-2/)

[prometheus](https://zaminhost.com/blog/%D9%BE%D8%B1%D9%88%D9%85%D8%AA%D8%A6%D9%88%D8%B3-prometheus/)

[opentelemetry/prometheus-metrics](https://uptrace.dev/opentelemetry/prometheus-metrics.html)

[prometheus-net](https://github.com/prometheus-net/prometheus-net)

[Monitoring a .NET application using OpenTelemetry](https://www.meziantou.net/monitoring-a-dotnet-application-using-opentelemetry.htm)

[ASP.NET Core Metrics with Prometheus](https://aevitas.medium.com/expose-asp-net-core-metrics-with-prometheus-15e3356415f4)

[System Monitoring And Alerting With Prometheus (Docker)](https://www.c-sharpcorner.com/blogs/system-monitoring-and-alerting-with-prometheusdocker-part-i)

[ PromQL](https://zaminhost.com/blog/%DA%A9%D9%88%D8%A6%D8%B1%DB%8C-%D8%AF%D8%B1-%D9%BE%D8%B1%D9%88%D9%85%D8%AA%D8%A6%D9%88%D8%B3/)

[tracking-dotnet-opentelemetry-metrics](https://code-maze.com/tracking-dotnet-opentelemetry-metrics/)
## prometheus.yml
``` yaml
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
```
## docker Prometheus
``` docker
docker run -d -p 9090:9090 -v D:\Practices\dotnetmetric_examples\prometheus:/etc/prometheus --name prometheus prom/prometheus
```
## grafana
```docker
docker run -d -p 3000:3000 -v D:\Practices\dotnetmetric_examplesgrafana/data:/var/lib/grafana --name grafana grafana/grafana
```

## ai
Instrumenting your application is a great way to monitor its performance, gather data, and gain insights into its behavior. Here are a few steps you can follow to instrument your application:

1. Choose a monitoring tool or framework: There are many options available, such as Prometheus, Grafana, New Relic, Datadog, and more. Research and select the one that best fits your requirements.

2. Identify key metrics and events: Determine the specific aspects of your application that you want to monitor. This could include metrics like response time, CPU/memory usage, error rates, or custom business-specific metrics.

2. Integrate the monitoring tool: Depending on your chosen tool, you will need to add its libraries or agents to your application code. These libraries will provide the necessary hooks to capture relevant data and send it to the monitoring system.

4. Define custom instrumentation points: If the default metrics provided by the monitoring tool are not enough, you can add your own instrumentation points in your code. These points will capture additional data specific to your application's behavior or logic.

5. Configure alerts and notifications: Set up alerts to notify you when certain conditions or thresholds are met. This way, you can proactively respond to critical issues and ensure the smooth operation of your application.

6. Test and iterate: Validate that the instrumentation is working as expected by generating sample data or running realistic scenarios. Monitor the collected metrics and make adjustments as needed to fine-tune the configuration.

Remember to consult the documentation and resources provided by your chosen monitoring tool for specific instructions on how to instrument your application effectively.

## user time and system time in context thread
In the context of threading, "user time" refers to the amount of time that a specific thread spends executing in user mode. User mode is a restricted execution mode where an application runs with limited privileges and access to system resources.

When a multi-threaded application is executing, each thread can consume both user time and system time. User time specifically represents the execution time spent within the application's code, including any computations, data manipulation, or function calls performed by the thread in user mode.

On the other hand, "system time" refers to the time spent by a thread executing code in kernel mode, which generally involves interactions with the operating system or accessing system resources.

By measuring the user time of a thread, you can gain insights into how much processing time a thread dedicates to executing application-specific code. This information can be useful for performance analysis, profiling, or identifying bottlenecks within the application.

It's important to note that user time and system time are distinct, and the total execution time of a thread can be a combination of both. `Tracking and analyzing these metrics can help optimize thread utilization and overall application performance.`
